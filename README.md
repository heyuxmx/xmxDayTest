一.这次的日测耗时一整天，在克服了种种困难之后，我达到了level 4，下面分享我编写的心路历程。
level 0比较简单，就是基础的环境设置，只需创建一个.c文件和Makefile文件作为初始化的工作即可，Makefile包含-Wall, -Wextra, -pedantic, -std=c99等编译选项。
level 1主要是为了在大体上明确接下来要做的工作，具体内容是为终端提供原始模式，有两个函数disableRowMode和enablRowMode，分别负责初始化模式和结束模式，main函数读取信息流，直到用户输入“q”退出。值得注意的是需要在enableRowMode中完成各种模式的禁用，如回显模式ECHO,规范模式ICONON，信号处理ISIG，IXON等，主要方法是手动修改结构体 raw.将修改后的结构体 raw 传递给 tcsetattr() 以写回新的终端属性，其他几个的禁用也是类似。
level 2要进行原始的输入输出处理，这就使编写的复杂度上升了不少，输入输出都涉及到很多基础知识，如何控制信息流以及如何判断终止等，在这一部分我在网上查阅了很多函数，才将代码写得完善。首先要进行键盘重构，需要创建一个用于低级按键读取的函数, 以及另一个用于将按键映射到编辑器操作的函数.，此时也将停止打印按键。接着要清除屏幕，重新定位光标等。我重点讲讲我设置窗口大小的过程，ioctl() 不能保证能够在所有系统上请求窗口大小, 因此我使用了一种获取窗口大小的备用方法，将光标定位在屏幕的右下角， 然后使用转义序列查询光标的位置，这告诉我们屏幕上肯定有多少行和多少列。在处理刷新屏幕时，每次都调用一大堆 write()，我就决定做一个大的 write()，以确保立即刷新整个屏幕。否则，在一堆 write() 调用之间可能会有不可预测的小停顿。我用将字符串追加到缓冲区的代码替换所有的 write() 调用，然后在最后调用 write() 将缓冲区输出. 因此我们将构建一种只支持追加操作的动态字符串类型。我创建一个新append buffer部分, 并在其下定义结构体 abuf，解决了这个问题。
level 3在level 2的基础上又加大了难度，从底层的输入输出处理转向数据模型的设计，在总体构架上有难度，这也困扰了我很久，在查阅各种资料后我才终于设计出了一个比较合适的结构。
level 4是从"只读查看器"到"可编辑器"的关键跃升，也是本次文本编辑器设计最关键的一步，我通过设置多行阅读器的方式完成了信息的读取，后续也陆续完成了保存，删除，脏位，行操作等内容，总体来说都不简单。可惜的是后续我没有更多的精力完成扩展的要求，在level 5上也没有太大进展，于是便阉割了最后一部分。
二.代码结构
我的代码包括部分。
第一部分，主要是各种库和宏的定义，比较基础。第二部分，我定义了三种结构体，edKey，erow和editorConfig，用于文本的处理。第三部分，就是我的代码的主要模块，有原始模式模块，行操作模块，写操作模块，文件IO模块，缓冲区模块，输出模块，输入模块以及初始化模块，分别解决了level 0到level 4逐层的问题。通过模块的设计我也感受到了逐层设计的魅力，各个模块互不干扰，但却能发挥出完整的作用，对我日后的编程也颇有帮助。
